{
	"type": "struct",
	"type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.App",
	"struct_fields": [
		{
			"key": "http_port",
			"value": {
				"type": "int",
				"doc": "HTTPPort specifies the port to use for HTTP (as opposed to HTTPS),\nwhich is used when setting up HTTP-\u003eHTTPS redirects or ACME HTTP\nchallenge solvers. Default: 80."
			},
			"doc": "HTTPPort specifies the port to use for HTTP (as opposed to HTTPS),\nwhich is used when setting up HTTP-\u003eHTTPS redirects or ACME HTTP\nchallenge solvers. Default: 80."
		},
		{
			"key": "https_port",
			"value": {
				"type": "int",
				"doc": "HTTPSPort specifies the port to use for HTTPS, which is used when\nsolving the ACME TLS-ALPN challenges, or whenever HTTPS is needed\nbut no specific port number is given. Default: 443."
			},
			"doc": "HTTPSPort specifies the port to use for HTTPS, which is used when\nsolving the ACME TLS-ALPN challenges, or whenever HTTPS is needed\nbut no specific port number is given. Default: 443."
		},
		{
			"key": "grace_period",
			"value": {
				"type": "int",
				"type_name": "github.com/caddyserver/caddy/v2.Duration",
				"doc": "GracePeriod is how long to wait for active connections when shutting\ndown the server. Once the grace period is over, connections will\nbe forcefully closed.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`µs`, `ms`, `s`, `m`, `h`, and `d`."
			},
			"doc": "GracePeriod is how long to wait for active connections when shutting\ndown the server. Once the grace period is over, connections will\nbe forcefully closed.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`µs`, `ms`, `s`, `m`, `h`, and `d`."
		},
		{
			"key": "servers",
			"value": {
				"type": "map",
				"map_keys": {
					"type": "string"
				},
				"elems": {
					"type": "struct",
					"type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.Server",
					"struct_fields": [
						{
							"key": "listen",
							"value": {
								"type": "array",
								"elems": {
									"type": "string",
									"doc": "Socket addresses to which to bind listeners. Accepts\n[network addresses](/docs/conventions#network-addresses)\nthat may include port ranges. Listener addresses must\nbe unique; they cannot be repeated across all defined\nservers."
								}
							},
							"doc": "Socket addresses to which to bind listeners. Accepts\n[network addresses](/docs/conventions#network-addresses)\nthat may include port ranges. Listener addresses must\nbe unique; they cannot be repeated across all defined\nservers."
						},
						{
							"key": "listener_wrappers",
							"value": {
								"type": "array",
								"elems": {
									"type": "module",
									"doc": "A list of listener wrapper modules, which can modify the behavior\nof the base listener. They are applied in the given order.",
									"module_namespace": "caddy.listeners",
									"module_inline_key": "wrapper"
								}
							},
							"doc": "A list of listener wrapper modules, which can modify the behavior\nof the base listener. They are applied in the given order."
						},
						{
							"key": "read_timeout",
							"value": {
								"type": "int",
								"type_name": "github.com/caddyserver/caddy/v2.Duration",
								"doc": "How long to allow a read from a client's upload. Setting this\nto a short, non-zero value can mitigate slowloris attacks, but\nmay also affect legitimately slow clients.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`µs`, `ms`, `s`, `m`, `h`, and `d`."
							},
							"doc": "How long to allow a read from a client's upload. Setting this\nto a short, non-zero value can mitigate slowloris attacks, but\nmay also affect legitimately slow clients.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`µs`, `ms`, `s`, `m`, `h`, and `d`."
						},
						{
							"key": "read_header_timeout",
							"value": {
								"type": "int",
								"type_name": "github.com/caddyserver/caddy/v2.Duration",
								"doc": "ReadHeaderTimeout is like ReadTimeout but for request headers.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`µs`, `ms`, `s`, `m`, `h`, and `d`."
							},
							"doc": "ReadHeaderTimeout is like ReadTimeout but for request headers.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`µs`, `ms`, `s`, `m`, `h`, and `d`."
						},
						{
							"key": "write_timeout",
							"value": {
								"type": "int",
								"type_name": "github.com/caddyserver/caddy/v2.Duration",
								"doc": "WriteTimeout is how long to allow a write to a client. Note\nthat setting this to a small value when serving large files\nmay negatively affect legitimately slow clients.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`µs`, `ms`, `s`, `m`, `h`, and `d`."
							},
							"doc": "WriteTimeout is how long to allow a write to a client. Note\nthat setting this to a small value when serving large files\nmay negatively affect legitimately slow clients.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`µs`, `ms`, `s`, `m`, `h`, and `d`."
						},
						{
							"key": "idle_timeout",
							"value": {
								"type": "int",
								"type_name": "github.com/caddyserver/caddy/v2.Duration",
								"doc": "IdleTimeout is the maximum time to wait for the next request\nwhen keep-alives are enabled. If zero, a default timeout of\n5m is applied to help avoid resource exhaustion.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`µs`, `ms`, `s`, `m`, `h`, and `d`."
							},
							"doc": "IdleTimeout is the maximum time to wait for the next request\nwhen keep-alives are enabled. If zero, a default timeout of\n5m is applied to help avoid resource exhaustion.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`µs`, `ms`, `s`, `m`, `h`, and `d`."
						},
						{
							"key": "max_header_bytes",
							"value": {
								"type": "int",
								"doc": "MaxHeaderBytes is the maximum size to parse from a client's\nHTTP request headers."
							},
							"doc": "MaxHeaderBytes is the maximum size to parse from a client's\nHTTP request headers."
						},
						{
							"key": "routes",
							"value": {
								"type": "array",
								"type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.RouteList",
								"elems": {
									"type": "struct",
									"type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.Route",
									"struct_fields": [
										{
											"key": "group",
											"value": {
												"type": "string",
												"doc": "Group is an optional name for a group to which this\nroute belongs. Grouping a route makes it mutually\nexclusive with others in its group; if a route belongs\nto a group, only the first matching route in that group\nwill be executed."
											},
											"doc": "Group is an optional name for a group to which this\nroute belongs. Grouping a route makes it mutually\nexclusive with others in its group; if a route belongs\nto a group, only the first matching route in that group\nwill be executed."
										},
										{
											"key": "match",
											"value": {
												"type": "array",
												"type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.RawMatcherSets",
												"elems": {
													"type": "module_map",
													"type_name": "github.com/caddyserver/caddy/v2.ModuleMap",
													"doc": "The matcher sets which will be used to qualify this\nroute for a request (essentially the \"if\" statement\nof this route). Each matcher set is OR'ed, but matchers\nwithin a set are AND'ed together.\n\n\nModuleMap is a map that can contain multiple modules,\nwhere the map key is the module's name. (The namespace\nis usually read from an associated field's struct tag.)\nBecause the module's name is given as the key in a\nmodule map, the name does not have to be given in the\njson.RawMessage.",
													"module_namespace": "http.matchers"
												},
												"doc": "RawMatcherSets is a group of matcher sets\nin their raw, JSON form.\n"
											},
											"doc": "The matcher sets which will be used to qualify this\nroute for a request (essentially the \"if\" statement\nof this route). Each matcher set is OR'ed, but matchers\nwithin a set are AND'ed together.\n\n\nModuleMap is a map that can contain multiple modules,\nwhere the map key is the module's name. (The namespace\nis usually read from an associated field's struct tag.)\nBecause the module's name is given as the key in a\nmodule map, the name does not have to be given in the\njson.RawMessage."
										},
										{
											"key": "handle",
											"value": {
												"type": "array",
												"elems": {
													"type": "module",
													"doc": "The list of handlers for this route. Upon matching a request, they are chained\ntogether in a middleware fashion: requests flow from the first handler to the last\n(top of the list to the bottom), with the possibility that any handler could stop\nthe chain and/or return an error. Responses flow back through the chain (bottom of\nthe list to the top) as they are written out to the client.\n\nNot all handlers call the next handler in the chain. For example, the reverse_proxy\nhandler always sends a request upstream or returns an error. Thus, configuring\nhandlers after reverse_proxy in the same route is illogical, since they would never\nbe executed. You will want to put handlers which originate the response at the very\nend of your route(s). The documentation for a module should state whether it invokes\nthe next handler, but sometimes it is common sense.\n\nSome handlers manipulate the response. Remember that requests flow down the list, and\nresponses flow up the list.\n\nFor example, if you wanted to use both `templates` and `encode` handlers, you would\nneed to put `templates` after `encode` in your route, because responses flow up.\nThus, `templates` will be able to parse and execute the plain-text response as a\ntemplate, and then return it up to the `encode` handler which will then compress it\ninto a binary format.\n\nIf `templates` came before `encode`, then `encode` would write a compressed,\nbinary-encoded response to `templates` which would not be able to parse the response\nproperly.\n\nThe correct order, then, is this:\n\n    [\n        {\"handler\": \"encode\"},\n        {\"handler\": \"templates\"},\n        {\"handler\": \"file_server\"}\n    ]\n\nThe request flows ⬇️ DOWN (`encode` -\u003e `templates` -\u003e `file_server`).\n\n1. First, `encode` will choose how to `encode` the response and wrap the response.\n2. Then, `templates` will wrap the response with a buffer.\n3. Finally, `file_server` will originate the content from a file.\n\nThe response flows ⬆️ UP (`file_server` -\u003e `templates` -\u003e `encode`):\n\n1. First, `file_server` will write the file to the response.\n2. That write will be buffered and then executed by `templates`.\n3. Lastly, the write from `templates` will flow into `encode` which will compress the stream.\n\nIf you think of routes in this way, it will be easy and even fun to solve the puzzle of writing correct routes.",
													"module_namespace": "http.handlers",
													"module_inline_key": "handler"
												}
											},
											"doc": "The list of handlers for this route. Upon matching a request, they are chained\ntogether in a middleware fashion: requests flow from the first handler to the last\n(top of the list to the bottom), with the possibility that any handler could stop\nthe chain and/or return an error. Responses flow back through the chain (bottom of\nthe list to the top) as they are written out to the client.\n\nNot all handlers call the next handler in the chain. For example, the reverse_proxy\nhandler always sends a request upstream or returns an error. Thus, configuring\nhandlers after reverse_proxy in the same route is illogical, since they would never\nbe executed. You will want to put handlers which originate the response at the very\nend of your route(s). The documentation for a module should state whether it invokes\nthe next handler, but sometimes it is common sense.\n\nSome handlers manipulate the response. Remember that requests flow down the list, and\nresponses flow up the list.\n\nFor example, if you wanted to use both `templates` and `encode` handlers, you would\nneed to put `templates` after `encode` in your route, because responses flow up.\nThus, `templates` will be able to parse and execute the plain-text response as a\ntemplate, and then return it up to the `encode` handler which will then compress it\ninto a binary format.\n\nIf `templates` came before `encode`, then `encode` would write a compressed,\nbinary-encoded response to `templates` which would not be able to parse the response\nproperly.\n\nThe correct order, then, is this:\n\n    [\n        {\"handler\": \"encode\"},\n        {\"handler\": \"templates\"},\n        {\"handler\": \"file_server\"}\n    ]\n\nThe request flows ⬇️ DOWN (`encode` -\u003e `templates` -\u003e `file_server`).\n\n1. First, `encode` will choose how to `encode` the response and wrap the response.\n2. Then, `templates` will wrap the response with a buffer.\n3. Finally, `file_server` will originate the content from a file.\n\nThe response flows ⬆️ UP (`file_server` -\u003e `templates` -\u003e `encode`):\n\n1. First, `file_server` will write the file to the response.\n2. That write will be buffered and then executed by `templates`.\n3. Lastly, the write from `templates` will flow into `encode` which will compress the stream.\n\nIf you think of routes in this way, it will be easy and even fun to solve the puzzle of writing correct routes."
										},
										{
											"key": "terminal",
											"value": {
												"type": "bool",
												"doc": "If true, no more routes will be executed after this one."
											},
											"doc": "If true, no more routes will be executed after this one."
										}
									],
									"doc": "Routes describes how this server will handle requests.\nRoutes are executed sequentially. First a route's matchers\nare evaluated, then its grouping. If it matches and has\nnot been mutually-excluded by its grouping, then its\nhandlers are executed sequentially. The sequence of invoked\nhandlers comprises a compiled middleware chain that flows\nfrom each matching route and its handlers to the next.\n\nBy default, all unrouted requests receive a 200 OK response\nto indicate the server is working.\n\n\nRoute consists of a set of rules for matching HTTP requests,\na list of handlers to execute, and optional flow control\nparameters which customize the handling of HTTP requests\nin a highly flexible and performant manner."
								},
								"doc": "RouteList is a list of server routes that can\ncreate a middleware chain.\n"
							},
							"doc": "Routes describes how this server will handle requests.\nRoutes are executed sequentially. First a route's matchers\nare evaluated, then its grouping. If it matches and has\nnot been mutually-excluded by its grouping, then its\nhandlers are executed sequentially. The sequence of invoked\nhandlers comprises a compiled middleware chain that flows\nfrom each matching route and its handlers to the next.\n\nBy default, all unrouted requests receive a 200 OK response\nto indicate the server is working.\n\n\nRoute consists of a set of rules for matching HTTP requests,\na list of handlers to execute, and optional flow control\nparameters which customize the handling of HTTP requests\nin a highly flexible and performant manner."
						},
						{
							"key": "errors",
							"value": {
								"type": "struct",
								"type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.HTTPErrorConfig",
								"struct_fields": [
									{
										"key": "routes",
										"value": {
											"type": "array",
											"type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.RouteList",
											"elems": {
												"type": "struct",
												"type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.Route",
												"struct_fields": [
													{
														"key": "group",
														"value": {
															"type": "string",
															"doc": "Group is an optional name for a group to which this\nroute belongs. Grouping a route makes it mutually\nexclusive with others in its group; if a route belongs\nto a group, only the first matching route in that group\nwill be executed."
														},
														"doc": "Group is an optional name for a group to which this\nroute belongs. Grouping a route makes it mutually\nexclusive with others in its group; if a route belongs\nto a group, only the first matching route in that group\nwill be executed."
													},
													{
														"key": "match",
														"value": {
															"type": "array",
															"type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.RawMatcherSets",
															"elems": {
																"type": "module_map",
																"type_name": "github.com/caddyserver/caddy/v2.ModuleMap",
																"doc": "The matcher sets which will be used to qualify this\nroute for a request (essentially the \"if\" statement\nof this route). Each matcher set is OR'ed, but matchers\nwithin a set are AND'ed together.\n\n\nModuleMap is a map that can contain multiple modules,\nwhere the map key is the module's name. (The namespace\nis usually read from an associated field's struct tag.)\nBecause the module's name is given as the key in a\nmodule map, the name does not have to be given in the\njson.RawMessage.",
																"module_namespace": "http.matchers"
															},
															"doc": "RawMatcherSets is a group of matcher sets\nin their raw, JSON form.\n"
														},
														"doc": "The matcher sets which will be used to qualify this\nroute for a request (essentially the \"if\" statement\nof this route). Each matcher set is OR'ed, but matchers\nwithin a set are AND'ed together.\n\n\nModuleMap is a map that can contain multiple modules,\nwhere the map key is the module's name. (The namespace\nis usually read from an associated field's struct tag.)\nBecause the module's name is given as the key in a\nmodule map, the name does not have to be given in the\njson.RawMessage."
													},
													{
														"key": "handle",
														"value": {
															"type": "array",
															"elems": {
																"type": "module",
																"doc": "The list of handlers for this route. Upon matching a request, they are chained\ntogether in a middleware fashion: requests flow from the first handler to the last\n(top of the list to the bottom), with the possibility that any handler could stop\nthe chain and/or return an error. Responses flow back through the chain (bottom of\nthe list to the top) as they are written out to the client.\n\nNot all handlers call the next handler in the chain. For example, the reverse_proxy\nhandler always sends a request upstream or returns an error. Thus, configuring\nhandlers after reverse_proxy in the same route is illogical, since they would never\nbe executed. You will want to put handlers which originate the response at the very\nend of your route(s). The documentation for a module should state whether it invokes\nthe next handler, but sometimes it is common sense.\n\nSome handlers manipulate the response. Remember that requests flow down the list, and\nresponses flow up the list.\n\nFor example, if you wanted to use both `templates` and `encode` handlers, you would\nneed to put `templates` after `encode` in your route, because responses flow up.\nThus, `templates` will be able to parse and execute the plain-text response as a\ntemplate, and then return it up to the `encode` handler which will then compress it\ninto a binary format.\n\nIf `templates` came before `encode`, then `encode` would write a compressed,\nbinary-encoded response to `templates` which would not be able to parse the response\nproperly.\n\nThe correct order, then, is this:\n\n    [\n        {\"handler\": \"encode\"},\n        {\"handler\": \"templates\"},\n        {\"handler\": \"file_server\"}\n    ]\n\nThe request flows ⬇️ DOWN (`encode` -\u003e `templates` -\u003e `file_server`).\n\n1. First, `encode` will choose how to `encode` the response and wrap the response.\n2. Then, `templates` will wrap the response with a buffer.\n3. Finally, `file_server` will originate the content from a file.\n\nThe response flows ⬆️ UP (`file_server` -\u003e `templates` -\u003e `encode`):\n\n1. First, `file_server` will write the file to the response.\n2. That write will be buffered and then executed by `templates`.\n3. Lastly, the write from `templates` will flow into `encode` which will compress the stream.\n\nIf you think of routes in this way, it will be easy and even fun to solve the puzzle of writing correct routes.",
																"module_namespace": "http.handlers",
																"module_inline_key": "handler"
															}
														},
														"doc": "The list of handlers for this route. Upon matching a request, they are chained\ntogether in a middleware fashion: requests flow from the first handler to the last\n(top of the list to the bottom), with the possibility that any handler could stop\nthe chain and/or return an error. Responses flow back through the chain (bottom of\nthe list to the top) as they are written out to the client.\n\nNot all handlers call the next handler in the chain. For example, the reverse_proxy\nhandler always sends a request upstream or returns an error. Thus, configuring\nhandlers after reverse_proxy in the same route is illogical, since they would never\nbe executed. You will want to put handlers which originate the response at the very\nend of your route(s). The documentation for a module should state whether it invokes\nthe next handler, but sometimes it is common sense.\n\nSome handlers manipulate the response. Remember that requests flow down the list, and\nresponses flow up the list.\n\nFor example, if you wanted to use both `templates` and `encode` handlers, you would\nneed to put `templates` after `encode` in your route, because responses flow up.\nThus, `templates` will be able to parse and execute the plain-text response as a\ntemplate, and then return it up to the `encode` handler which will then compress it\ninto a binary format.\n\nIf `templates` came before `encode`, then `encode` would write a compressed,\nbinary-encoded response to `templates` which would not be able to parse the response\nproperly.\n\nThe correct order, then, is this:\n\n    [\n        {\"handler\": \"encode\"},\n        {\"handler\": \"templates\"},\n        {\"handler\": \"file_server\"}\n    ]\n\nThe request flows ⬇️ DOWN (`encode` -\u003e `templates` -\u003e `file_server`).\n\n1. First, `encode` will choose how to `encode` the response and wrap the response.\n2. Then, `templates` will wrap the response with a buffer.\n3. Finally, `file_server` will originate the content from a file.\n\nThe response flows ⬆️ UP (`file_server` -\u003e `templates` -\u003e `encode`):\n\n1. First, `file_server` will write the file to the response.\n2. That write will be buffered and then executed by `templates`.\n3. Lastly, the write from `templates` will flow into `encode` which will compress the stream.\n\nIf you think of routes in this way, it will be easy and even fun to solve the puzzle of writing correct routes."
													},
													{
														"key": "terminal",
														"value": {
															"type": "bool",
															"doc": "If true, no more routes will be executed after this one."
														},
														"doc": "If true, no more routes will be executed after this one."
													}
												],
												"doc": "The routes to evaluate after the primary handler\nchain returns an error. In an error route, extra\nplaceholders are available:\n\nPlaceholder | Description\n------------|---------------\n`{http.error.status_code}` | The recommended HTTP status code\n`{http.error.status_text}` | The status text associated with the recommended status code\n`{http.error.message}`     | The error message\n`{http.error.trace}`       | The origin of the error\n`{http.error.id}`          | An identifier for this occurrence of the error\n\n\nRoute consists of a set of rules for matching HTTP requests,\na list of handlers to execute, and optional flow control\nparameters which customize the handling of HTTP requests\nin a highly flexible and performant manner."
											},
											"doc": "RouteList is a list of server routes that can\ncreate a middleware chain.\n"
										},
										"doc": "The routes to evaluate after the primary handler\nchain returns an error. In an error route, extra\nplaceholders are available:\n\nPlaceholder | Description\n------------|---------------\n`{http.error.status_code}` | The recommended HTTP status code\n`{http.error.status_text}` | The status text associated with the recommended status code\n`{http.error.message}`     | The error message\n`{http.error.trace}`       | The origin of the error\n`{http.error.id}`          | An identifier for this occurrence of the error\n\n\nRoute consists of a set of rules for matching HTTP requests,\na list of handlers to execute, and optional flow control\nparameters which customize the handling of HTTP requests\nin a highly flexible and performant manner."
									}
								],
								"doc": "Errors is how this server will handle errors returned from any\nof the handlers in the primary routes. If the primary handler\nchain returns an error, the error along with its recommended\nstatus code are bubbled back up to the HTTP server which\nexecutes a separate error route, specified using this property.\nThe error routes work exactly like the normal routes.\n\n\nHTTPErrorConfig determines how to handle errors\nfrom the HTTP handlers."
							},
							"doc": "Errors is how this server will handle errors returned from any\nof the handlers in the primary routes. If the primary handler\nchain returns an error, the error along with its recommended\nstatus code are bubbled back up to the HTTP server which\nexecutes a separate error route, specified using this property.\nThe error routes work exactly like the normal routes.\n\n\nHTTPErrorConfig determines how to handle errors\nfrom the HTTP handlers."
						},
						{
							"key": "tls_connection_policies",
							"value": {
								"type": "array",
								"type_name": "github.com/caddyserver/caddy/v2/modules/caddytls.ConnectionPolicies",
								"elems": {
									"type": "struct",
									"type_name": "github.com/caddyserver/caddy/v2/modules/caddytls.ConnectionPolicy",
									"struct_fields": [
										{
											"key": "match",
											"value": {
												"type": "module_map",
												"type_name": "github.com/caddyserver/caddy/v2.ModuleMap",
												"doc": "How to match this policy with a TLS ClientHello. If\nthis policy is the first to match, it will be used.\n\n\nModuleMap is a map that can contain multiple modules,\nwhere the map key is the module's name. (The namespace\nis usually read from an associated field's struct tag.)\nBecause the module's name is given as the key in a\nmodule map, the name does not have to be given in the\njson.RawMessage.",
												"module_namespace": "tls.handshake_match"
											},
											"doc": "How to match this policy with a TLS ClientHello. If\nthis policy is the first to match, it will be used.\n\n\nModuleMap is a map that can contain multiple modules,\nwhere the map key is the module's name. (The namespace\nis usually read from an associated field's struct tag.)\nBecause the module's name is given as the key in a\nmodule map, the name does not have to be given in the\njson.RawMessage."
										},
										{
											"key": "certificate_selection",
											"value": {
												"type": "struct",
												"type_name": "github.com/caddyserver/caddy/v2/modules/caddytls.CustomCertSelectionPolicy",
												"struct_fields": [
													{
														"key": "serial_number",
														"value": {
															"type": "array",
															"elems": {
																"type": "struct",
																"type_name": "github.com/caddyserver/caddy/v2/modules/caddytls.bigInt",
																"doc": "The certificate must have one of these serial numbers.\n\n\nbigInt is a big.Int type that interops with JSON encodings as a string."
															}
														},
														"doc": "The certificate must have one of these serial numbers.\n\n\nbigInt is a big.Int type that interops with JSON encodings as a string."
													},
													{
														"key": "subject_organization",
														"value": {
															"type": "array",
															"elems": {
																"type": "string",
																"doc": "The certificate must have one of these organization names."
															}
														},
														"doc": "The certificate must have one of these organization names."
													},
													{
														"key": "public_key_algorithm",
														"value": {
															"type": "int",
															"type_name": "github.com/caddyserver/caddy/v2/modules/caddytls.PublicKeyAlgorithm",
															"doc": "The certificate must use this public key algorithm.\n\n\nPublicKeyAlgorithm is a JSON-unmarshalable wrapper type."
														},
														"doc": "The certificate must use this public key algorithm.\n\n\nPublicKeyAlgorithm is a JSON-unmarshalable wrapper type."
													},
													{
														"key": "any_tag",
														"value": {
															"type": "array",
															"elems": {
																"type": "string",
																"doc": "The certificate must have at least one of the tags in the list."
															}
														},
														"doc": "The certificate must have at least one of the tags in the list."
													},
													{
														"key": "all_tags",
														"value": {
															"type": "array",
															"elems": {
																"type": "string",
																"doc": "The certificate must have all of the tags in the list."
															}
														},
														"doc": "The certificate must have all of the tags in the list."
													}
												],
												"doc": "How to choose a certificate if more than one matched\nthe given ServerName (SNI) value.\n\n\nCustomCertSelectionPolicy represents a policy for selecting the certificate\nused to complete a handshake when there may be multiple options. All fields\nspecified must match the candidate certificate for it to be chosen.\nThis was needed to solve https://github.com/caddyserver/caddy/issues/2588."
											},
											"doc": "How to choose a certificate if more than one matched\nthe given ServerName (SNI) value.\n\n\nCustomCertSelectionPolicy represents a policy for selecting the certificate\nused to complete a handshake when there may be multiple options. All fields\nspecified must match the candidate certificate for it to be chosen.\nThis was needed to solve https://github.com/caddyserver/caddy/issues/2588."
										},
										{
											"key": "cipher_suites",
											"value": {
												"type": "array",
												"elems": {
													"type": "string",
													"doc": "The list of cipher suites to support. Caddy's\ndefaults are modern and secure."
												}
											},
											"doc": "The list of cipher suites to support. Caddy's\ndefaults are modern and secure."
										},
										{
											"key": "curves",
											"value": {
												"type": "array",
												"elems": {
													"type": "string",
													"doc": "The list of elliptic curves to support. Caddy's\ndefaults are modern and secure."
												}
											},
											"doc": "The list of elliptic curves to support. Caddy's\ndefaults are modern and secure."
										},
										{
											"key": "alpn",
											"value": {
												"type": "array",
												"elems": {
													"type": "string",
													"doc": "Protocols to use for Application-Layer Protocol\nNegotiation (ALPN) during the handshake."
												}
											},
											"doc": "Protocols to use for Application-Layer Protocol\nNegotiation (ALPN) during the handshake."
										},
										{
											"key": "protocol_min",
											"value": {
												"type": "string",
												"doc": "Minimum TLS protocol version to allow. Default: `tls1.2`"
											},
											"doc": "Minimum TLS protocol version to allow. Default: `tls1.2`"
										},
										{
											"key": "protocol_max",
											"value": {
												"type": "string",
												"doc": "Maximum TLS protocol version to allow. Default: `tls1.3`"
											},
											"doc": "Maximum TLS protocol version to allow. Default: `tls1.3`"
										},
										{
											"key": "client_authentication",
											"value": {
												"type": "struct",
												"type_name": "github.com/caddyserver/caddy/v2/modules/caddytls.ClientAuthentication",
												"struct_fields": [
													{
														"key": "trusted_ca_certs",
														"value": {
															"type": "array",
															"elems": {
																"type": "string",
																"doc": "A list of base64 DER-encoded CA certificates\nagainst which to validate client certificates.\nClient certs which are not signed by any of\nthese CAs will be rejected."
															}
														},
														"doc": "A list of base64 DER-encoded CA certificates\nagainst which to validate client certificates.\nClient certs which are not signed by any of\nthese CAs will be rejected."
													},
													{
														"key": "trusted_ca_certs_pem_files",
														"value": {
															"type": "array",
															"elems": {
																"type": "string",
																"doc": "TrustedCACertPEMFiles is a list of PEM file names\nfrom which to load certificates of trusted CAs.\nClient certificates which are not signed by any of\nthese CA certificates will be rejected."
															}
														},
														"doc": "TrustedCACertPEMFiles is a list of PEM file names\nfrom which to load certificates of trusted CAs.\nClient certificates which are not signed by any of\nthese CA certificates will be rejected."
													},
													{
														"key": "trusted_leaf_certs",
														"value": {
															"type": "array",
															"elems": {
																"type": "string",
																"doc": "A list of base64 DER-encoded client leaf certs\nto accept. If this list is not empty, client certs\nwhich are not in this list will be rejected."
															}
														},
														"doc": "A list of base64 DER-encoded client leaf certs\nto accept. If this list is not empty, client certs\nwhich are not in this list will be rejected."
													},
													{
														"key": "mode",
														"value": {
															"type": "string",
															"doc": "The mode for authenticating the client. Allowed values are:\n\nMode | Description\n-----|---------------\n`request` | Ask clients for a certificate, but allow even if there isn't one; do not verify it\n`require` | Require clients to present a certificate, but do not verify it\n`verify_if_given` | Ask clients for a certificate; allow even if there isn't one, but verify it if there is\n`require_and_verify` | Require clients to present a valid certificate that is verified\n\nThe default mode is `require_and_verify` if any\nTrustedCACerts or TrustedCACertPEMFiles or TrustedLeafCerts\nare provided; otherwise, the default mode is `require`."
														},
														"doc": "The mode for authenticating the client. Allowed values are:\n\nMode | Description\n-----|---------------\n`request` | Ask clients for a certificate, but allow even if there isn't one; do not verify it\n`require` | Require clients to present a certificate, but do not verify it\n`verify_if_given` | Ask clients for a certificate; allow even if there isn't one, but verify it if there is\n`require_and_verify` | Require clients to present a valid certificate that is verified\n\nThe default mode is `require_and_verify` if any\nTrustedCACerts or TrustedCACertPEMFiles or TrustedLeafCerts\nare provided; otherwise, the default mode is `require`."
													}
												],
												"doc": "Enables and configures TLS client authentication.\n\n\nClientAuthentication configures TLS client auth."
											},
											"doc": "Enables and configures TLS client authentication.\n\n\nClientAuthentication configures TLS client auth."
										},
										{
											"key": "default_sni",
											"value": {
												"type": "string",
												"doc": "DefaultSNI becomes the ServerName in a ClientHello if there\nis no policy configured for the empty SNI value."
											},
											"doc": "DefaultSNI becomes the ServerName in a ClientHello if there\nis no policy configured for the empty SNI value."
										}
									],
									"doc": "How to handle TLS connections. At least one policy is\nrequired to enable HTTPS on this server if automatic\nHTTPS is disabled or does not apply.\n\n\nConnectionPolicy specifies the logic for handling a TLS handshake.\nAn empty policy is valid; safe and sensible defaults will be used."
								},
								"doc": "ConnectionPolicies govern the establishment of TLS connections. It is\nan ordered group of connection policies; the first matching policy will\nbe used to configure TLS connections at handshake-time.\n"
							},
							"doc": "How to handle TLS connections. At least one policy is\nrequired to enable HTTPS on this server if automatic\nHTTPS is disabled or does not apply.\n\n\nConnectionPolicy specifies the logic for handling a TLS handshake.\nAn empty policy is valid; safe and sensible defaults will be used."
						},
						{
							"key": "automatic_https",
							"value": {
								"type": "struct",
								"type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.AutoHTTPSConfig",
								"struct_fields": [
									{
										"key": "disable",
										"value": {
											"type": "bool",
											"doc": "If true, automatic HTTPS will be entirely disabled."
										},
										"doc": "If true, automatic HTTPS will be entirely disabled."
									},
									{
										"key": "disable_redirects",
										"value": {
											"type": "bool",
											"doc": "If true, only automatic HTTP-\u003eHTTPS redirects will\nbe disabled."
										},
										"doc": "If true, only automatic HTTP-\u003eHTTPS redirects will\nbe disabled."
									},
									{
										"key": "skip",
										"value": {
											"type": "array",
											"elems": {
												"type": "string",
												"doc": "Hosts/domain names listed here will not be included\nin automatic HTTPS (they will not have certificates\nloaded nor redirects applied)."
											}
										},
										"doc": "Hosts/domain names listed here will not be included\nin automatic HTTPS (they will not have certificates\nloaded nor redirects applied)."
									},
									{
										"key": "skip_certificates",
										"value": {
											"type": "array",
											"elems": {
												"type": "string",
												"doc": "Hosts/domain names listed here will still be enabled\nfor automatic HTTPS (unless in the Skip list), except\nthat certificates will not be provisioned and managed\nfor these names."
											}
										},
										"doc": "Hosts/domain names listed here will still be enabled\nfor automatic HTTPS (unless in the Skip list), except\nthat certificates will not be provisioned and managed\nfor these names."
									},
									{
										"key": "ignore_loaded_certificates",
										"value": {
											"type": "bool",
											"doc": "By default, automatic HTTPS will obtain and renew\ncertificates for qualifying hostnames. However, if\na certificate with a matching SAN is already loaded\ninto the cache, certificate management will not be\nenabled. To force automated certificate management\nregardless of loaded certificates, set this to true."
										},
										"doc": "By default, automatic HTTPS will obtain and renew\ncertificates for qualifying hostnames. However, if\na certificate with a matching SAN is already loaded\ninto the cache, certificate management will not be\nenabled. To force automated certificate management\nregardless of loaded certificates, set this to true."
									}
								],
								"doc": "AutoHTTPS configures or disables automatic HTTPS within this server.\nHTTPS is enabled automatically and by default when qualifying names\nare present in a Host matcher and/or when the server is listening\nonly on the HTTPS port.\n\n\nAutoHTTPSConfig is used to disable automatic HTTPS\nor certain aspects of it for a specific server.\nHTTPS is enabled automatically and by default when\nqualifying hostnames are available from the config."
							},
							"doc": "AutoHTTPS configures or disables automatic HTTPS within this server.\nHTTPS is enabled automatically and by default when qualifying names\nare present in a Host matcher and/or when the server is listening\nonly on the HTTPS port.\n\n\nAutoHTTPSConfig is used to disable automatic HTTPS\nor certain aspects of it for a specific server.\nHTTPS is enabled automatically and by default when\nqualifying hostnames are available from the config."
						},
						{
							"key": "strict_sni_host",
							"value": {
								"type": "bool",
								"doc": "If true, will require that a request's Host header match\nthe value of the ServerName sent by the client's TLS\nClientHello; often a necessary safeguard when using TLS\nclient authentication."
							},
							"doc": "If true, will require that a request's Host header match\nthe value of the ServerName sent by the client's TLS\nClientHello; often a necessary safeguard when using TLS\nclient authentication."
						},
						{
							"key": "logs",
							"value": {
								"type": "struct",
								"type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.ServerLogConfig",
								"struct_fields": [
									{
										"key": "default_logger_name",
										"value": {
											"type": "string",
											"doc": "The default logger name for all logs emitted by this server for\nhostnames that are not in the LoggerNames (logger_names) map."
										},
										"doc": "The default logger name for all logs emitted by this server for\nhostnames that are not in the LoggerNames (logger_names) map."
									},
									{
										"key": "logger_names",
										"value": {
											"type": "map",
											"map_keys": {
												"type": "string"
											},
											"elems": {
												"type": "string",
												"doc": "LoggerNames maps request hostnames to a custom logger name.\nFor example, a mapping of \"example.com\" to \"example\" would\ncause access logs from requests with a Host of example.com\nto be emitted by a logger named \"http.log.access.example\"."
											}
										},
										"doc": "LoggerNames maps request hostnames to a custom logger name.\nFor example, a mapping of \"example.com\" to \"example\" would\ncause access logs from requests with a Host of example.com\nto be emitted by a logger named \"http.log.access.example\"."
									},
									{
										"key": "skip_hosts",
										"value": {
											"type": "array",
											"elems": {
												"type": "string",
												"doc": "By default, all requests to this server will be logged if\naccess logging is enabled. This field lists the request\nhosts for which access logging should be disabled."
											}
										},
										"doc": "By default, all requests to this server will be logged if\naccess logging is enabled. This field lists the request\nhosts for which access logging should be disabled."
									},
									{
										"key": "skip_unmapped_hosts",
										"value": {
											"type": "bool",
											"doc": "If true, requests to any host not appearing in the\nLoggerNames (logger_names) map will not be logged."
										},
										"doc": "If true, requests to any host not appearing in the\nLoggerNames (logger_names) map will not be logged."
									}
								],
								"doc": "Enables access logging and configures how access logs are handled\nin this server. To minimally enable access logs, simply set this\nto a non-null, empty struct.\n\n\nServerLogConfig describes a server's logging configuration. If\nenabled without customization, all requests to this server are\nlogged to the default logger; logger destinations may be\ncustomized per-request-host."
							},
							"doc": "Enables access logging and configures how access logs are handled\nin this server. To minimally enable access logs, simply set this\nto a non-null, empty struct.\n\n\nServerLogConfig describes a server's logging configuration. If\nenabled without customization, all requests to this server are\nlogged to the default logger; logger destinations may be\ncustomized per-request-host."
						},
						{
							"key": "experimental_http3",
							"value": {
								"type": "bool",
								"doc": "Enable experimental HTTP/3 support. Note that HTTP/3 is not a\nfinished standard and has extremely limited client support.\nThis field is not subject to compatibility promises."
							},
							"doc": "Enable experimental HTTP/3 support. Note that HTTP/3 is not a\nfinished standard and has extremely limited client support.\nThis field is not subject to compatibility promises."
						},
						{
							"key": "allow_h2c",
							"value": {
								"type": "bool",
								"doc": "Enables H2C (\"Cleartext HTTP/2\" or \"H2 over TCP\") support,\nwhich will serve HTTP/2 over plaintext TCP connections if\nthe client supports it. Because this is not implemented by the\nGo standard library, using H2C is incompatible with most\nof the other options for this server. Do not enable this\nonly to achieve maximum client compatibility. In practice,\nvery few clients implement H2C, and even fewer require it.\nThis setting applies only to unencrypted HTTP listeners.\n⚠️ Experimental feature; subject to change or removal."
							},
							"doc": "Enables H2C (\"Cleartext HTTP/2\" or \"H2 over TCP\") support,\nwhich will serve HTTP/2 over plaintext TCP connections if\nthe client supports it. Because this is not implemented by the\nGo standard library, using H2C is incompatible with most\nof the other options for this server. Do not enable this\nonly to achieve maximum client compatibility. In practice,\nvery few clients implement H2C, and even fewer require it.\nThis setting applies only to unencrypted HTTP listeners.\n⚠️ Experimental feature; subject to change or removal."
						}
					],
					"doc": "Servers is the list of servers, keyed by arbitrary names chosen\nat your discretion for your own convenience; the keys do not\naffect functionality.\n\n\nServer describes an HTTP server."
				}
			},
			"doc": "Servers is the list of servers, keyed by arbitrary names chosen\nat your discretion for your own convenience; the keys do not\naffect functionality.\n\n\nServer describes an HTTP server."
		}
	],
	"doc": "App is a robust, production-ready HTTP server.\n\nHTTPS is enabled by default if host matchers with qualifying names are used\nin any of routes; certificates are automatically provisioned and renewed.\nAdditionally, automatic HTTPS will also enable HTTPS for servers that listen\nonly on the HTTPS port but which do not have any TLS connection policies\ndefined by adding a good, default TLS connection policy.\n\nIn HTTP routes, additional placeholders are available (replace any `*`):\n\nPlaceholder | Description\n------------|---------------\n`{http.request.body}` | The request body (⚠️ inefficient; use only for debugging)\n`{http.request.cookie.*}` | HTTP request cookie\n`{http.request.duration}` | Time up to now spent handling the request (after decoding headers from client)\n`{http.request.header.*}` | Specific request header field\n`{http.request.host.labels.*}` | Request host labels (0-based from right); e.g. for foo.example.com: 0=com, 1=example, 2=foo\n`{http.request.host}` | The host part of the request's Host header\n`{http.request.hostport}` | The host and port from the request's Host header\n`{http.request.method}` | The request method\n`{http.request.orig_method}` | The request's original method\n`{http.request.orig_uri.path.dir}` | The request's original directory\n`{http.request.orig_uri.path.file}` | The request's original filename\n`{http.request.orig_uri.path}` | The request's original path\n`{http.request.orig_uri.query}` | The request's original query string (without `?`)\n`{http.request.orig_uri}` | The request's original URI\n`{http.request.port}` | The port part of the request's Host header\n`{http.request.proto}` | The protocol of the request\n`{http.request.remote.host}` | The host part of the remote client's address\n`{http.request.remote.port}` | The port part of the remote client's address\n`{http.request.remote}` | The address of the remote client\n`{http.request.scheme}` | The request scheme\n`{http.request.tls.version}` | The TLS version name\n`{http.request.tls.cipher_suite}` | The TLS cipher suite\n`{http.request.tls.resumed}` | The TLS connection resumed a previous connection\n`{http.request.tls.proto}` | The negotiated next protocol\n`{http.request.tls.proto_mutual}` | The negotiated next protocol was advertised by the server\n`{http.request.tls.server_name}` | The server name requested by the client, if any\n`{http.request.tls.client.fingerprint}` | The SHA256 checksum of the client certificate\n`{http.request.tls.client.public_key}` | The public key of the client certificate.\n`{http.request.tls.client.public_key_sha256}` | The SHA256 checksum of the client's public key.\n`{http.request.tls.client.certificate_pem}` | The PEM-encoded value of the certificate.\n`{http.request.tls.client.certificate_der_base64}` | The base64-encoded value of the certificate.\n`{http.request.tls.client.issuer}` | The issuer DN of the client certificate\n`{http.request.tls.client.serial}` | The serial number of the client certificate\n`{http.request.tls.client.subject}` | The subject DN of the client certificate\n`{http.request.tls.client.san.dns_names.*}` | SAN DNS names(index optional)\n`{http.request.tls.client.san.emails.*}` | SAN email addresses (index optional)\n`{http.request.tls.client.san.ips.*}` | SAN IP addresses (index optional)\n`{http.request.tls.client.san.uris.*}` | SAN URIs (index optional)\n`{http.request.uri.path.*}` | Parts of the path, split by `/` (0-based from left)\n`{http.request.uri.path.dir}` | The directory, excluding leaf filename\n`{http.request.uri.path.file}` | The filename of the path, excluding directory\n`{http.request.uri.path}` | The path component of the request URI\n`{http.request.uri.query.*}` | Individual query string value\n`{http.request.uri.query}` | The query string (without `?`)\n`{http.request.uri}` | The full request URI\n`{http.response.header.*}` | Specific response header field\n`{http.vars.*}` | Custom variables in the HTTP handler chain\n"
}