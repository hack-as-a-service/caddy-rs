{"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp/reverseproxy.Handler", "struct_fields": [{"key": "transport", "value": {"type": "module", "doc": "Configures the method of transport for the proxy. A transport\nis what performs the actual \"round trip\" to the backend.\nThe default transport is plaintext HTTP.", "module_namespace": "http.reverse_proxy.transport", "module_inline_key": "protocol"}, "doc": "Configures the method of transport for the proxy. A transport\nis what performs the actual \"round trip\" to the backend.\nThe default transport is plaintext HTTP."}, {"key": "circuit_breaker", "value": {"type": "module", "doc": "A circuit breaker may be used to relieve pressure on a backend\nthat is beginning to exhibit symptoms of stress or latency.\nBy default, there is no circuit breaker.", "module_namespace": "http.reverse_proxy.circuit_breakers", "module_inline_key": "type"}, "doc": "A circuit breaker may be used to relieve pressure on a backend\nthat is beginning to exhibit symptoms of stress or latency.\nBy default, there is no circuit breaker."}, {"key": "load_balancing", "value": {"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp/reverseproxy.LoadBalancing", "struct_fields": [{"key": "selection_policy", "value": {"type": "module", "doc": "A selection policy is how to choose an available backend.\nThe default policy is random selection.", "module_namespace": "http.reverse_proxy.selection_policies", "module_inline_key": "policy"}, "doc": "A selection policy is how to choose an available backend.\nThe default policy is random selection."}, {"key": "try_duration", "value": {"type": "int", "type_name": "github.com/caddyserver/caddy/v2.Duration", "doc": "How long to try selecting available backends for each request\nif the next available host is down. By default, this retry is\ndisabled. Clients will wait for up to this long while the load\nbalancer tries to find an available upstream host.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`\u00b5s`, `ms`, `s`, `m`, `h`, and `d`."}, "doc": "How long to try selecting available backends for each request\nif the next available host is down. By default, this retry is\ndisabled. Clients will wait for up to this long while the load\nbalancer tries to find an available upstream host.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`\u00b5s`, `ms`, `s`, `m`, `h`, and `d`."}, {"key": "try_interval", "value": {"type": "int", "type_name": "github.com/caddyserver/caddy/v2.Duration", "doc": "How long to wait between selecting the next host from the pool. Default\nis 250ms. Only relevant when a request to an upstream host fails. Be\naware that setting this to 0 with a non-zero try_duration can cause the\nCPU to spin if all backends are down and latency is very low.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`\u00b5s`, `ms`, `s`, `m`, `h`, and `d`."}, "doc": "How long to wait between selecting the next host from the pool. Default\nis 250ms. Only relevant when a request to an upstream host fails. Be\naware that setting this to 0 with a non-zero try_duration can cause the\nCPU to spin if all backends are down and latency is very low.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`\u00b5s`, `ms`, `s`, `m`, `h`, and `d`."}, {"key": "retry_match", "value": {"type": "array", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.RawMatcherSets", "elems": {"type": "module_map", "type_name": "github.com/caddyserver/caddy/v2.ModuleMap", "doc": "A list of matcher sets that restricts with which requests retries are\nallowed. A request must match any of the given matcher sets in order\nto be retried if the connection to the upstream succeeded but the\nsubsequent round-trip failed. If the connection to the upstream failed,\na retry is always allowed. If unspecified, only GET requests will be\nallowed to be retried. Note that a retry is done with the next available\nhost according to the load balancing policy.\n\n\nModuleMap is a map that can contain multiple modules,\nwhere the map key is the module's name. (The namespace\nis usually read from an associated field's struct tag.)\nBecause the module's name is given as the key in a\nmodule map, the name does not have to be given in the\njson.RawMessage.", "module_namespace": "http.matchers"}, "doc": "RawMatcherSets is a group of matcher sets\nin their raw, JSON form.\n"}, "doc": "A list of matcher sets that restricts with which requests retries are\nallowed. A request must match any of the given matcher sets in order\nto be retried if the connection to the upstream succeeded but the\nsubsequent round-trip failed. If the connection to the upstream failed,\na retry is always allowed. If unspecified, only GET requests will be\nallowed to be retried. Note that a retry is done with the next available\nhost according to the load balancing policy.\n\n\nModuleMap is a map that can contain multiple modules,\nwhere the map key is the module's name. (The namespace\nis usually read from an associated field's struct tag.)\nBecause the module's name is given as the key in a\nmodule map, the name does not have to be given in the\njson.RawMessage."}], "doc": "Load balancing distributes load/requests between backends.\n\n\nLoadBalancing has parameters related to load balancing."}, "doc": "Load balancing distributes load/requests between backends.\n\n\nLoadBalancing has parameters related to load balancing."}, {"key": "health_checks", "value": {"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp/reverseproxy.HealthChecks", "struct_fields": [{"key": "active", "value": {"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp/reverseproxy.ActiveHealthChecks", "struct_fields": [{"key": "path", "value": {"type": "string", "doc": "The path to use for health checks.\nDEPRECATED: Use 'uri' instead."}, "doc": "The path to use for health checks.\nDEPRECATED: Use 'uri' instead."}, {"key": "uri", "value": {"type": "string", "doc": "The URI (path and query) to use for health checks"}, "doc": "The URI (path and query) to use for health checks"}, {"key": "port", "value": {"type": "int", "doc": "The port to use (if different from the upstream's dial\naddress) for health checks."}, "doc": "The port to use (if different from the upstream's dial\naddress) for health checks."}, {"key": "headers", "value": {"type": "map", "type_name": "net/http.Header", "map_keys": {"type": "string"}, "elems": {"type": "array", "elems": {"type": "string"}, "doc": "HTTP headers to set on health check requests."}, "doc": "A Header represents the key-value pairs in an HTTP header.\n\nThe keys should be in canonical form, as returned by\nCanonicalHeaderKey.\n"}, "doc": "HTTP headers to set on health check requests."}, {"key": "interval", "value": {"type": "int", "type_name": "github.com/caddyserver/caddy/v2.Duration", "doc": "How frequently to perform active health checks (default 30s).\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`\u00b5s`, `ms`, `s`, `m`, `h`, and `d`."}, "doc": "How frequently to perform active health checks (default 30s).\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`\u00b5s`, `ms`, `s`, `m`, `h`, and `d`."}, {"key": "timeout", "value": {"type": "int", "type_name": "github.com/caddyserver/caddy/v2.Duration", "doc": "How long to wait for a response from a backend before\nconsidering it unhealthy (default 5s).\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`\u00b5s`, `ms`, `s`, `m`, `h`, and `d`."}, "doc": "How long to wait for a response from a backend before\nconsidering it unhealthy (default 5s).\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`\u00b5s`, `ms`, `s`, `m`, `h`, and `d`."}, {"key": "max_size", "value": {"type": "int", "doc": "The maximum response body to download from the backend\nduring a health check."}, "doc": "The maximum response body to download from the backend\nduring a health check."}, {"key": "expect_status", "value": {"type": "int", "doc": "The HTTP status code to expect from a healthy backend."}, "doc": "The HTTP status code to expect from a healthy backend."}, {"key": "expect_body", "value": {"type": "string", "doc": "A regular expression against which to match the response\nbody of a healthy backend."}, "doc": "A regular expression against which to match the response\nbody of a healthy backend."}], "doc": "Active health checks run in the background on a timer. To\nminimally enable active health checks, set either path or\nport (or both).\n\n\nActiveHealthChecks holds configuration related to active\nhealth checks (that is, health checks which occur in a\nbackground goroutine independently)."}, "doc": "Active health checks run in the background on a timer. To\nminimally enable active health checks, set either path or\nport (or both).\n\n\nActiveHealthChecks holds configuration related to active\nhealth checks (that is, health checks which occur in a\nbackground goroutine independently)."}, {"key": "passive", "value": {"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp/reverseproxy.PassiveHealthChecks", "struct_fields": [{"key": "fail_duration", "value": {"type": "int", "type_name": "github.com/caddyserver/caddy/v2.Duration", "doc": "How long to remember a failed request to a backend. A duration > 0\nenables passive health checking. Default is 0.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`\u00b5s`, `ms`, `s`, `m`, `h`, and `d`."}, "doc": "How long to remember a failed request to a backend. A duration > 0\nenables passive health checking. Default is 0.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`\u00b5s`, `ms`, `s`, `m`, `h`, and `d`."}, {"key": "max_fails", "value": {"type": "int", "doc": "The number of failed requests within the FailDuration window to\nconsider a backend as \"down\". Must be >= 1; default is 1. Requires\nthat FailDuration be > 0."}, "doc": "The number of failed requests within the FailDuration window to\nconsider a backend as \"down\". Must be >= 1; default is 1. Requires\nthat FailDuration be > 0."}, {"key": "unhealthy_request_count", "value": {"type": "int", "doc": "Limits the number of simultaneous requests to a backend by\nmarking the backend as \"down\" if it has this many concurrent\nrequests or more."}, "doc": "Limits the number of simultaneous requests to a backend by\nmarking the backend as \"down\" if it has this many concurrent\nrequests or more."}, {"key": "unhealthy_status", "value": {"type": "array", "elems": {"type": "int", "doc": "Count the request as failed if the response comes back with\none of these status codes."}}, "doc": "Count the request as failed if the response comes back with\none of these status codes."}, {"key": "unhealthy_latency", "value": {"type": "int", "type_name": "github.com/caddyserver/caddy/v2.Duration", "doc": "Count the request as failed if the response takes at least this\nlong to receive.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`\u00b5s`, `ms`, `s`, `m`, `h`, and `d`."}, "doc": "Count the request as failed if the response takes at least this\nlong to receive.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`\u00b5s`, `ms`, `s`, `m`, `h`, and `d`."}], "doc": "Passive health checks monitor proxied requests for errors or timeouts.\nTo minimally enable passive health checks, specify at least an empty\nconfig object.\n\n\nPassiveHealthChecks holds configuration related to passive\nhealth checks (that is, health checks which occur during\nthe normal flow of request proxying)."}, "doc": "Passive health checks monitor proxied requests for errors or timeouts.\nTo minimally enable passive health checks, specify at least an empty\nconfig object.\n\n\nPassiveHealthChecks holds configuration related to passive\nhealth checks (that is, health checks which occur during\nthe normal flow of request proxying)."}], "doc": "Health checks update the status of backends, whether they are\nup or down. Down backends will not be proxied to.\n\n\nHealthChecks configures active and passive health checks."}, "doc": "Health checks update the status of backends, whether they are\nup or down. Down backends will not be proxied to.\n\n\nHealthChecks configures active and passive health checks."}, {"key": "upstreams", "value": {"type": "array", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp/reverseproxy.UpstreamPool", "elems": {"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp/reverseproxy.Upstream", "struct_fields": [{"key": "dial", "value": {"type": "string", "doc": "The [network address](/docs/conventions#network-addresses)\nto dial to connect to the upstream. Must represent precisely\none socket (i.e. no port ranges). A valid network address\neither has a host and port or is a unix socket address.\n\nPlaceholders may be used to make the upstream dynamic, but be\naware of the health check implications of this: a single\nupstream that represents numerous (perhaps arbitrary) backends\ncan be considered down if one or enough of the arbitrary\nbackends is down. Also be aware of open proxy vulnerabilities."}, "doc": "The [network address](/docs/conventions#network-addresses)\nto dial to connect to the upstream. Must represent precisely\none socket (i.e. no port ranges). A valid network address\neither has a host and port or is a unix socket address.\n\nPlaceholders may be used to make the upstream dynamic, but be\naware of the health check implications of this: a single\nupstream that represents numerous (perhaps arbitrary) backends\ncan be considered down if one or enough of the arbitrary\nbackends is down. Also be aware of open proxy vulnerabilities."}, {"key": "lookup_srv", "value": {"type": "string", "doc": "If DNS SRV records are used for service discovery with this\nupstream, specify the DNS name for which to look up SRV\nrecords here, instead of specifying a dial address."}, "doc": "If DNS SRV records are used for service discovery with this\nupstream, specify the DNS name for which to look up SRV\nrecords here, instead of specifying a dial address."}, {"key": "max_requests", "value": {"type": "int", "doc": "The maximum number of simultaneous requests to allow to\nthis upstream. If set, overrides the global passive health\ncheck UnhealthyRequestCount value."}, "doc": "The maximum number of simultaneous requests to allow to\nthis upstream. If set, overrides the global passive health\ncheck UnhealthyRequestCount value."}], "doc": "Upstreams is the list of backends to proxy to.\n\n\nUpstream bridges this proxy's configuration to the\nstate of the backend host it is correlated with."}, "doc": "UpstreamPool is a collection of upstreams.\n"}, "doc": "Upstreams is the list of backends to proxy to.\n\n\nUpstream bridges this proxy's configuration to the\nstate of the backend host it is correlated with."}, {"key": "flush_interval", "value": {"type": "int", "type_name": "github.com/caddyserver/caddy/v2.Duration", "doc": "Adjusts how often to flush the response buffer. By default,\nno periodic flushing is done. A negative value disables\nresponse buffering, and flushes immediately after each\nwrite to the client. This option is ignored when the upstream's\nresponse is recognized as a streaming response, or if its\ncontent length is -1; for such responses, writes are flushed\nto the client immediately.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`\u00b5s`, `ms`, `s`, `m`, `h`, and `d`."}, "doc": "Adjusts how often to flush the response buffer. By default,\nno periodic flushing is done. A negative value disables\nresponse buffering, and flushes immediately after each\nwrite to the client. This option is ignored when the upstream's\nresponse is recognized as a streaming response, or if its\ncontent length is -1; for such responses, writes are flushed\nto the client immediately.\n\n\nDuration can be an integer or a string. An integer is\ninterpreted as nanoseconds. If a string, it is a Go\ntime.Duration value such as `300ms`, `1.5h`, or `2h45m`;\nvalid units are `ns`, `us`/`\u00b5s`, `ms`, `s`, `m`, `h`, and `d`."}, {"key": "headers", "value": {"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp/headers.Handler", "struct_fields": [{"key": "request", "value": {"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp/headers.HeaderOps", "struct_fields": [{"key": "add", "value": {"type": "map", "type_name": "net/http.Header", "map_keys": {"type": "string"}, "elems": {"type": "array", "elems": {"type": "string"}, "doc": "Adds HTTP headers; does not replace any existing header fields."}, "doc": "A Header represents the key-value pairs in an HTTP header.\n\nThe keys should be in canonical form, as returned by\nCanonicalHeaderKey.\n"}, "doc": "Adds HTTP headers; does not replace any existing header fields."}, {"key": "set", "value": {"type": "map", "type_name": "net/http.Header", "map_keys": {"type": "string"}, "elems": {"type": "array", "elems": {"type": "string"}, "doc": "Sets HTTP headers; replaces existing header fields."}, "doc": "A Header represents the key-value pairs in an HTTP header.\n\nThe keys should be in canonical form, as returned by\nCanonicalHeaderKey.\n"}, "doc": "Sets HTTP headers; replaces existing header fields."}, {"key": "delete", "value": {"type": "array", "elems": {"type": "string", "doc": "Names of HTTP header fields to delete."}}, "doc": "Names of HTTP header fields to delete."}, {"key": "replace", "value": {"type": "map", "map_keys": {"type": "string"}, "elems": {"type": "array", "elems": {"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp/headers.Replacement", "struct_fields": [{"key": "search", "value": {"type": "string", "doc": "The substring to search for."}, "doc": "The substring to search for."}, {"key": "search_regexp", "value": {"type": "string", "doc": "The regular expression to search with."}, "doc": "The regular expression to search with."}, {"key": "replace", "value": {"type": "string", "doc": "The string with which to replace matches."}, "doc": "The string with which to replace matches."}], "doc": "Replacement describes a string replacement,\neither a simple and fast substring search\nor a slower but more powerful regex search.\n"}, "doc": "Performs substring replacements of HTTP headers in-situ."}}, "doc": "Performs substring replacements of HTTP headers in-situ."}], "doc": "HeaderOps defines manipulations for HTTP headers.\n"}, "doc": "HeaderOps defines manipulations for HTTP headers.\n"}, {"key": "response", "value": {"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp/headers.RespHeaderOps", "struct_fields": [{"key": "add", "value": {"type": "map", "type_name": "net/http.Header", "map_keys": {"type": "string"}, "elems": {"type": "array", "elems": {"type": "string"}, "doc": "Adds HTTP headers; does not replace any existing header fields."}, "doc": "A Header represents the key-value pairs in an HTTP header.\n\nThe keys should be in canonical form, as returned by\nCanonicalHeaderKey.\n"}, "doc": "Adds HTTP headers; does not replace any existing header fields."}, {"key": "set", "value": {"type": "map", "type_name": "net/http.Header", "map_keys": {"type": "string"}, "elems": {"type": "array", "elems": {"type": "string"}, "doc": "Sets HTTP headers; replaces existing header fields."}, "doc": "A Header represents the key-value pairs in an HTTP header.\n\nThe keys should be in canonical form, as returned by\nCanonicalHeaderKey.\n"}, "doc": "Sets HTTP headers; replaces existing header fields."}, {"key": "delete", "value": {"type": "array", "elems": {"type": "string", "doc": "Names of HTTP header fields to delete."}}, "doc": "Names of HTTP header fields to delete."}, {"key": "replace", "value": {"type": "map", "map_keys": {"type": "string"}, "elems": {"type": "array", "elems": {"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp/headers.Replacement", "struct_fields": [{"key": "search", "value": {"type": "string", "doc": "The substring to search for."}, "doc": "The substring to search for."}, {"key": "search_regexp", "value": {"type": "string", "doc": "The regular expression to search with."}, "doc": "The regular expression to search with."}, {"key": "replace", "value": {"type": "string", "doc": "The string with which to replace matches."}, "doc": "The string with which to replace matches."}], "doc": "Replacement describes a string replacement,\neither a simple and fast substring search\nor a slower but more powerful regex search.\n"}, "doc": "Performs substring replacements of HTTP headers in-situ."}}, "doc": "Performs substring replacements of HTTP headers in-situ."}, {"key": "require", "value": {"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.ResponseMatcher", "struct_fields": [{"key": "status_code", "value": {"type": "array", "elems": {"type": "int", "doc": "If set, one of these status codes would be required.\nA one-digit status can be used to represent all codes\nin that class (e.g. 3 for all 3xx codes)."}}, "doc": "If set, one of these status codes would be required.\nA one-digit status can be used to represent all codes\nin that class (e.g. 3 for all 3xx codes)."}, {"key": "headers", "value": {"type": "map", "type_name": "net/http.Header", "map_keys": {"type": "string"}, "elems": {"type": "array", "elems": {"type": "string"}, "doc": "If set, each header specified must be one of the\nspecified values, with the same logic used by the\nrequest header matcher."}, "doc": "A Header represents the key-value pairs in an HTTP header.\n\nThe keys should be in canonical form, as returned by\nCanonicalHeaderKey.\n"}, "doc": "If set, each header specified must be one of the\nspecified values, with the same logic used by the\nrequest header matcher."}], "doc": "If set, header operations will be deferred until\nthey are written out and only performed if the\nresponse matches these criteria.\n\n\nResponseMatcher is a type which can determine if an\nHTTP response matches some criteria."}, "doc": "If set, header operations will be deferred until\nthey are written out and only performed if the\nresponse matches these criteria.\n\n\nResponseMatcher is a type which can determine if an\nHTTP response matches some criteria."}, {"key": "deferred", "value": {"type": "bool", "doc": "If true, header operations will be deferred until\nthey are written out. Superceded if Require is set.\nUsually you will need to set this to true if any\nfields are being deleted."}, "doc": "If true, header operations will be deferred until\nthey are written out. Superceded if Require is set.\nUsually you will need to set this to true if any\nfields are being deleted."}], "doc": "RespHeaderOps defines manipulations for response headers.\n"}, "doc": "RespHeaderOps defines manipulations for response headers.\n"}], "doc": "Headers manipulates headers between Caddy and the backend.\nBy default, all headers are passed-thru without changes,\nwith the exceptions of special hop-by-hop headers.\n\nX-Forwarded-For and X-Forwarded-Proto are also set\nimplicitly, but this may change in the future if the official\nstandardized Forwarded header field gains more adoption.\n\n\nHandler is a middleware which modifies request and response headers.\n\nChanges to headers are applied immediately, except for the response\nheaders when Deferred is true or when Required is set. In those cases,\nthe changes are applied when the headers are written to the response.\nNote that deferred changes do not take effect if an error occurs later\nin the middleware chain.\n\nProperties in this module accept placeholders.\n\nResponse header operations can be conditioned upon response status code\nand/or other header values."}, "doc": "Headers manipulates headers between Caddy and the backend.\nBy default, all headers are passed-thru without changes,\nwith the exceptions of special hop-by-hop headers.\n\nX-Forwarded-For and X-Forwarded-Proto are also set\nimplicitly, but this may change in the future if the official\nstandardized Forwarded header field gains more adoption.\n\n\nHandler is a middleware which modifies request and response headers.\n\nChanges to headers are applied immediately, except for the response\nheaders when Deferred is true or when Required is set. In those cases,\nthe changes are applied when the headers are written to the response.\nNote that deferred changes do not take effect if an error occurs later\nin the middleware chain.\n\nProperties in this module accept placeholders.\n\nResponse header operations can be conditioned upon response status code\nand/or other header values."}, {"key": "buffer_requests", "value": {"type": "bool", "doc": "If true, the entire request body will be read and buffered\nin memory before being proxied to the backend. This should\nbe avoided if at all possible for performance reasons, but\ncould be useful if the backend is intolerant of read latency."}, "doc": "If true, the entire request body will be read and buffered\nin memory before being proxied to the backend. This should\nbe avoided if at all possible for performance reasons, but\ncould be useful if the backend is intolerant of read latency."}, {"key": "buffer_responses", "value": {"type": "bool", "doc": "If true, the entire response body will be read and buffered\nin memory before being proxied to the client. This should\nbe avoided if at all possible for performance reasons, but\ncould be useful if the backend has tighter memory constraints."}, "doc": "If true, the entire response body will be read and buffered\nin memory before being proxied to the client. This should\nbe avoided if at all possible for performance reasons, but\ncould be useful if the backend has tighter memory constraints."}, {"key": "max_buffer_size", "value": {"type": "int", "doc": "If body buffering is enabled, the maximum size of the buffers\nused for the requests and responses (in bytes)."}, "doc": "If body buffering is enabled, the maximum size of the buffers\nused for the requests and responses (in bytes)."}, {"key": "handle_response", "value": {"type": "array", "elems": {"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.ResponseHandler", "struct_fields": [{"key": "match", "value": {"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.ResponseMatcher", "struct_fields": [{"key": "status_code", "value": {"type": "array", "elems": {"type": "int", "doc": "If set, one of these status codes would be required.\nA one-digit status can be used to represent all codes\nin that class (e.g. 3 for all 3xx codes)."}}, "doc": "If set, one of these status codes would be required.\nA one-digit status can be used to represent all codes\nin that class (e.g. 3 for all 3xx codes)."}, {"key": "headers", "value": {"type": "map", "type_name": "net/http.Header", "map_keys": {"type": "string"}, "elems": {"type": "array", "elems": {"type": "string"}, "doc": "If set, each header specified must be one of the\nspecified values, with the same logic used by the\nrequest header matcher."}, "doc": "A Header represents the key-value pairs in an HTTP header.\n\nThe keys should be in canonical form, as returned by\nCanonicalHeaderKey.\n"}, "doc": "If set, each header specified must be one of the\nspecified values, with the same logic used by the\nrequest header matcher."}], "doc": "The response matcher for this handler. If empty/nil,\nit always matches.\n\n\nResponseMatcher is a type which can determine if an\nHTTP response matches some criteria."}, "doc": "The response matcher for this handler. If empty/nil,\nit always matches.\n\n\nResponseMatcher is a type which can determine if an\nHTTP response matches some criteria."}, {"key": "status_code", "value": {"type": "string", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.WeakString", "doc": "To write the original response body but with a different\nstatus code, set this field to the desired status code.\nIf set, this takes priority over routes.\n\n\nWeakString is a type that unmarshals any JSON value\nas a string literal, with the following exceptions:\n\n1. actual string values are decoded as strings; and\n2. null is decoded as empty string;\n\nand provides methods for getting the value as various\nprimitive types. However, using this type removes any\ntype safety as far as deserializing JSON is concerned."}, "doc": "To write the original response body but with a different\nstatus code, set this field to the desired status code.\nIf set, this takes priority over routes.\n\n\nWeakString is a type that unmarshals any JSON value\nas a string literal, with the following exceptions:\n\n1. actual string values are decoded as strings; and\n2. null is decoded as empty string;\n\nand provides methods for getting the value as various\nprimitive types. However, using this type removes any\ntype safety as far as deserializing JSON is concerned."}, {"key": "routes", "value": {"type": "array", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.RouteList", "elems": {"type": "struct", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.Route", "struct_fields": [{"key": "group", "value": {"type": "string", "doc": "Group is an optional name for a group to which this\nroute belongs. Grouping a route makes it mutually\nexclusive with others in its group; if a route belongs\nto a group, only the first matching route in that group\nwill be executed."}, "doc": "Group is an optional name for a group to which this\nroute belongs. Grouping a route makes it mutually\nexclusive with others in its group; if a route belongs\nto a group, only the first matching route in that group\nwill be executed."}, {"key": "match", "value": {"type": "array", "type_name": "github.com/caddyserver/caddy/v2/modules/caddyhttp.RawMatcherSets", "elems": {"type": "module_map", "type_name": "github.com/caddyserver/caddy/v2.ModuleMap", "doc": "The matcher sets which will be used to qualify this\nroute for a request (essentially the \"if\" statement\nof this route). Each matcher set is OR'ed, but matchers\nwithin a set are AND'ed together.\n\n\nModuleMap is a map that can contain multiple modules,\nwhere the map key is the module's name. (The namespace\nis usually read from an associated field's struct tag.)\nBecause the module's name is given as the key in a\nmodule map, the name does not have to be given in the\njson.RawMessage.", "module_namespace": "http.matchers"}, "doc": "RawMatcherSets is a group of matcher sets\nin their raw, JSON form.\n"}, "doc": "The matcher sets which will be used to qualify this\nroute for a request (essentially the \"if\" statement\nof this route). Each matcher set is OR'ed, but matchers\nwithin a set are AND'ed together.\n\n\nModuleMap is a map that can contain multiple modules,\nwhere the map key is the module's name. (The namespace\nis usually read from an associated field's struct tag.)\nBecause the module's name is given as the key in a\nmodule map, the name does not have to be given in the\njson.RawMessage."}, {"key": "handle", "value": {"type": "array", "elems": {"type": "module", "doc": "The list of handlers for this route. Upon matching a request, they are chained\ntogether in a middleware fashion: requests flow from the first handler to the last\n(top of the list to the bottom), with the possibility that any handler could stop\nthe chain and/or return an error. Responses flow back through the chain (bottom of\nthe list to the top) as they are written out to the client.\n\nNot all handlers call the next handler in the chain. For example, the reverse_proxy\nhandler always sends a request upstream or returns an error. Thus, configuring\nhandlers after reverse_proxy in the same route is illogical, since they would never\nbe executed. You will want to put handlers which originate the response at the very\nend of your route(s). The documentation for a module should state whether it invokes\nthe next handler, but sometimes it is common sense.\n\nSome handlers manipulate the response. Remember that requests flow down the list, and\nresponses flow up the list.\n\nFor example, if you wanted to use both `templates` and `encode` handlers, you would\nneed to put `templates` after `encode` in your route, because responses flow up.\nThus, `templates` will be able to parse and execute the plain-text response as a\ntemplate, and then return it up to the `encode` handler which will then compress it\ninto a binary format.\n\nIf `templates` came before `encode`, then `encode` would write a compressed,\nbinary-encoded response to `templates` which would not be able to parse the response\nproperly.\n\nThe correct order, then, is this:\n\n    [\n        {\"handler\": \"encode\"},\n        {\"handler\": \"templates\"},\n        {\"handler\": \"file_server\"}\n    ]\n\nThe request flows \u2b07\ufe0f DOWN (`encode` -> `templates` -> `file_server`).\n\n1. First, `encode` will choose how to `encode` the response and wrap the response.\n2. Then, `templates` will wrap the response with a buffer.\n3. Finally, `file_server` will originate the content from a file.\n\nThe response flows \u2b06\ufe0f UP (`file_server` -> `templates` -> `encode`):\n\n1. First, `file_server` will write the file to the response.\n2. That write will be buffered and then executed by `templates`.\n3. Lastly, the write from `templates` will flow into `encode` which will compress the stream.\n\nIf you think of routes in this way, it will be easy and even fun to solve the puzzle of writing correct routes.", "module_namespace": "http.handlers", "module_inline_key": "handler"}}, "doc": "The list of handlers for this route. Upon matching a request, they are chained\ntogether in a middleware fashion: requests flow from the first handler to the last\n(top of the list to the bottom), with the possibility that any handler could stop\nthe chain and/or return an error. Responses flow back through the chain (bottom of\nthe list to the top) as they are written out to the client.\n\nNot all handlers call the next handler in the chain. For example, the reverse_proxy\nhandler always sends a request upstream or returns an error. Thus, configuring\nhandlers after reverse_proxy in the same route is illogical, since they would never\nbe executed. You will want to put handlers which originate the response at the very\nend of your route(s). The documentation for a module should state whether it invokes\nthe next handler, but sometimes it is common sense.\n\nSome handlers manipulate the response. Remember that requests flow down the list, and\nresponses flow up the list.\n\nFor example, if you wanted to use both `templates` and `encode` handlers, you would\nneed to put `templates` after `encode` in your route, because responses flow up.\nThus, `templates` will be able to parse and execute the plain-text response as a\ntemplate, and then return it up to the `encode` handler which will then compress it\ninto a binary format.\n\nIf `templates` came before `encode`, then `encode` would write a compressed,\nbinary-encoded response to `templates` which would not be able to parse the response\nproperly.\n\nThe correct order, then, is this:\n\n    [\n        {\"handler\": \"encode\"},\n        {\"handler\": \"templates\"},\n        {\"handler\": \"file_server\"}\n    ]\n\nThe request flows \u2b07\ufe0f DOWN (`encode` -> `templates` -> `file_server`).\n\n1. First, `encode` will choose how to `encode` the response and wrap the response.\n2. Then, `templates` will wrap the response with a buffer.\n3. Finally, `file_server` will originate the content from a file.\n\nThe response flows \u2b06\ufe0f UP (`file_server` -> `templates` -> `encode`):\n\n1. First, `file_server` will write the file to the response.\n2. That write will be buffered and then executed by `templates`.\n3. Lastly, the write from `templates` will flow into `encode` which will compress the stream.\n\nIf you think of routes in this way, it will be easy and even fun to solve the puzzle of writing correct routes."}, {"key": "terminal", "value": {"type": "bool", "doc": "If true, no more routes will be executed after this one."}, "doc": "If true, no more routes will be executed after this one."}], "doc": "The list of HTTP routes to execute if no status code is\nspecified. If evaluated, the original response body\nwill not be written.\n\n\nRoute consists of a set of rules for matching HTTP requests,\na list of handlers to execute, and optional flow control\nparameters which customize the handling of HTTP requests\nin a highly flexible and performant manner."}, "doc": "RouteList is a list of server routes that can\ncreate a middleware chain.\n"}, "doc": "The list of HTTP routes to execute if no status code is\nspecified. If evaluated, the original response body\nwill not be written.\n\n\nRoute consists of a set of rules for matching HTTP requests,\na list of handlers to execute, and optional flow control\nparameters which customize the handling of HTTP requests\nin a highly flexible and performant manner."}], "doc": "List of handlers and their associated matchers to evaluate\nafter successful roundtrips. The first handler that matches\nthe response from a backend will be invoked. The response\nbody from the backend will not be written to the client;\nit is up to the handler to finish handling the response.\nIf passive health checks are enabled, any errors from the\nhandler chain will not affect the health status of the\nbackend.\n\nThree new placeholders are available in this handler chain:\n- `{http.reverse_proxy.status_code}` The status code from the response\n- `{http.reverse_proxy.status_text}` The status text from the response\n- `{http.reverse_proxy.header.*}` The headers from the response\n\n\nResponseHandler pairs a response matcher with custom handling\nlogic. Either the status code can be changed to something else\nwhile using the original response body, or, if a status code\nis not set, it can execute a custom route list; this is useful\nfor executing handler routes based on the properties of an HTTP\nresponse that has not been written out to the client yet.\n\nTo use this type, provision it at module load time, then when\nready to use, match the response against its matcher; if it\nmatches (or doesn't have a matcher), change the status code on\nthe response if configured; otherwise invoke the routes by\ncalling `rh.Routes.Compile(next).ServeHTTP(rw, req)` (or similar)."}}, "doc": "List of handlers and their associated matchers to evaluate\nafter successful roundtrips. The first handler that matches\nthe response from a backend will be invoked. The response\nbody from the backend will not be written to the client;\nit is up to the handler to finish handling the response.\nIf passive health checks are enabled, any errors from the\nhandler chain will not affect the health status of the\nbackend.\n\nThree new placeholders are available in this handler chain:\n- `{http.reverse_proxy.status_code}` The status code from the response\n- `{http.reverse_proxy.status_text}` The status text from the response\n- `{http.reverse_proxy.header.*}` The headers from the response\n\n\nResponseHandler pairs a response matcher with custom handling\nlogic. Either the status code can be changed to something else\nwhile using the original response body, or, if a status code\nis not set, it can execute a custom route list; this is useful\nfor executing handler routes based on the properties of an HTTP\nresponse that has not been written out to the client yet.\n\nTo use this type, provision it at module load time, then when\nready to use, match the response against its matcher; if it\nmatches (or doesn't have a matcher), change the status code on\nthe response if configured; otherwise invoke the routes by\ncalling `rh.Routes.Compile(next).ServeHTTP(rw, req)` (or similar)."}], "doc": "Handler implements a highly configurable and production-ready reverse proxy.\n\nUpon proxying, this module sets the following placeholders (which can be used\nboth within and after this handler; for example, in response headers):\n\nPlaceholder | Description\n------------|-------------\n`{http.reverse_proxy.upstream.address}` | The full address to the upstream as given in the config\n`{http.reverse_proxy.upstream.hostport}` | The host:port of the upstream\n`{http.reverse_proxy.upstream.host}` | The host of the upstream\n`{http.reverse_proxy.upstream.port}` | The port of the upstream\n`{http.reverse_proxy.upstream.requests}` | The approximate current number of requests to the upstream\n`{http.reverse_proxy.upstream.max_requests}` | The maximum approximate number of requests allowed to the upstream\n`{http.reverse_proxy.upstream.fails}` | The number of recent failed requests to the upstream\n`{http.reverse_proxy.upstream.latency}` | How long it took the proxy upstream to write the response header.\n`{http.reverse_proxy.upstream.duration}` | Time spent proxying to the upstream, including writing response body to client.\n`{http.reverse_proxy.duration}` | Total time spent proxying, including selecting an upstream, retries, and writing response.\n", "module_inline_key": "handler"}